{
  "language": "Solidity",
  "sources": {
    "contracts/GoGame.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Convert.sol\";\n\nerror GoGame__PlayerDontHaveMatch();\nerror GoGame__GameIsOver();\nerror GoGame__IsNotYourTurn();\nerror GoGame__InvalidPlacing();\n\ncontract GoGame {\n    enum StoneType {\n        None, // 0\n        Black, // 1\n        White // 2\n    }\n\n    struct GameState {\n        StoneType[19 * 19] boardState; // current board state\n        StoneType turn; // whos turn is it now\n        bool isOver;\n    }\n\n    struct PlayerState {\n        StoneType stoneType;\n        uint256 matchId;\n        bool inGame;\n    }\n\n    event FindMatch(uint256 indexed matchId, address player1, address player2);\n    event GameStateChange(uint256 indexed matchId);\n    event GameOver(uint256 indexed matchId, address winner);\n\n    address[] matchQueue;\n    mapping(uint256 => GameState) matchIdToGS; // index by match id\n    mapping(address => PlayerState) addressToPS; // index by address\n    uint32 matchCnt;\n\n    /* public & external function  */\n\n    function requestMatch() public {\n        address[] memory mq = matchQueue;\n        if (mq.length == 0) {\n            matchQueue.push(msg.sender);\n        } else if (mq.length == 1) {\n            // check is in queue already\n            if (mq[0] == msg.sender) return;\n            // match\n            // create new game\n            uint256 matchId = createNewGame(mq[0], msg.sender);\n            // emit event\n            emit FindMatch(matchId, mq[0], msg.sender);\n            // clear match queue\n            delete matchQueue;\n        }\n    }\n\n    // player place stone\n    function PlaceStone(\n        uint8 x,\n        uint8 y,\n        bool checkWin\n    ) public {\n        // find out player match\n        PlayerState memory ps = addressToPS[msg.sender];\n        if (ps.matchId == 0) {\n            revert GoGame__PlayerDontHaveMatch();\n        }\n        // check is game is not over and is player turn\n        GameState memory gs = matchIdToGS[ps.matchId];\n        if (gs.isOver) {\n            revert GoGame__GameIsOver();\n        }\n        if (gs.turn != ps.stoneType) {\n            revert GoGame__IsNotYourTurn();\n        }\n        // check place index is valid\n        if (\n            (x < 0 || x >= 19) ||\n            (y < 0 || y >= 19) ||\n            gs.boardState[x + y * 19] != StoneType.None\n        ) {\n            revert GoGame__InvalidPlacing();\n        }\n\n        // place stone\n        matchIdToGS[ps.matchId].boardState[x + y * 19] = ps.stoneType;\n        matchIdToGS[ps.matchId].turn = ps.stoneType == StoneType.White\n            ? StoneType.Black\n            : StoneType.White;\n        emit GameStateChange(ps.matchId);\n\n        if (checkWin) {\n            // check win condition\n            // 1. up -> right -> down -> left\n            uint8[8] memory cnt;\n            int8[2][4][8] memory vecs = [\n                [\n                    [int8(0), int8(1)],\n                    [int8(0), int8(2)],\n                    [int8(0), int8(3)],\n                    [int8(0), int8(4)]\n                ],\n                [\n                    [int8(1), int8(1)],\n                    [int8(2), int8(2)],\n                    [int8(3), int8(3)],\n                    [int8(4), int8(4)]\n                ],\n                [\n                    [int8(1), int8(0)],\n                    [int8(2), int8(0)],\n                    [int8(3), int8(0)],\n                    [int8(4), int8(0)]\n                ],\n                [\n                    [int8(1), int8(-1)],\n                    [int8(2), int8(-2)],\n                    [int8(3), int8(-3)],\n                    [int8(4), int8(-4)]\n                ],\n                [\n                    [int8(0), int8(-1)],\n                    [int8(0), int8(-2)],\n                    [int8(0), int8(-3)],\n                    [int8(0), int8(-4)]\n                ],\n                [\n                    [int8(-1), int8(-1)],\n                    [int8(-2), int8(-2)],\n                    [int8(-3), int8(-3)],\n                    [int8(-4), int8(-4)]\n                ],\n                [\n                    [int8(-1), int8(0)],\n                    [int8(-2), int8(0)],\n                    [int8(-3), int8(0)],\n                    [int8(-4), int8(0)]\n                ],\n                [\n                    [int8(-1), int8(1)],\n                    [int8(-2), int8(2)],\n                    [int8(-3), int8(3)],\n                    [int8(-4), int8(4)]\n                ]\n            ];\n\n            for (uint8 i = 0; i < 8; i++) {\n                for (uint8 j = 0; j < 4; j++) {\n                    // checking index\n                    int8 nx = int8(x) + vecs[i][j][0];\n                    int8 ny = int8(y) + vecs[i][j][1];\n                    // check out of bound\n                    if (nx < 0 || nx >= 19 || ny < 0 || ny >= 19) break;\n                    // if line is continuous\n                    if (\n                        gs.boardState[\n                            uint16(uint8(nx)) + 19 * uint16(uint8(ny))\n                        ] == ps.stoneType\n                    ) {\n                        // cnt add\n                        cnt[i]++;\n                    } else {\n                        // this line is done\n                        break;\n                    }\n                }\n            }\n\n            // check have 5 in a line\n            for (uint8 i = 0; i < 4; i++) {\n                if (cnt[i] + cnt[i + 4] >= 4) {\n                    // win\n\n                    matchIdToGS[ps.matchId].isOver = true;\n                    emit GameOver(ps.matchId, msg.sender);\n                    break;\n                }\n            }\n        }\n    }\n\n    /* private & internal function */\n\n    function createNewGame(address p1, address p2)\n        private\n        returns (uint256 matchId)\n    {\n        // initial game state\n        StoneType[361] memory boardState;\n        GameState memory gs = GameState(boardState, StoneType.Black, false);\n        // add to map\n        matchIdToGS[++matchCnt] = gs;\n        // decide who is white/black\n        bool p1IsWhite = decideStoneType(p1, p2);\n        // init player state\n        StoneType p1Stone = p1IsWhite ? StoneType.White : StoneType.Black;\n        StoneType p2Stone = p1IsWhite ? StoneType.Black : StoneType.White;\n        // add to map\n        addressToPS[p1] = PlayerState(p1Stone, matchCnt, true);\n        addressToPS[p2] = PlayerState(p2Stone, matchCnt, true);\n\n        return matchCnt;\n    }\n\n    function decideStoneType(address p1, address p2)\n        private\n        view\n        returns (bool p1IsWhite)\n    {\n        bytes32 randomHash = sha256(\n            abi.encodePacked(\n                Convert.addressToBytes32(p1) ^\n                    Convert.addressToBytes32(p2) ^\n                    Convert.uint256ToBytes32(block.timestamp)\n            )\n        );\n\n        if (uint256(randomHash) % 2 == 0) {\n            // p1 is white\n            return true;\n        } else {\n            // p2 is white\n            return false;\n        }\n    }\n\n    /* pure & view function */\n    function BoardState(uint256 matchId)\n        public\n        view\n        returns (StoneType[361] memory)\n    {\n        return matchIdToGS[matchId].boardState;\n    }\n\n    function WhosTurn(uint256 matchId) public view returns (StoneType) {\n        return matchIdToGS[matchId].turn;\n    }\n\n    function MyPlayerState() public view returns (PlayerState memory) {\n        return addressToPS[msg.sender];\n    }\n}\n"
    },
    "contracts/Convert.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary Convert {\n  function addressToUint256(address a) public pure returns (uint256) {\n    return uint256(uint160(a));\n  }\n\n  function addressToBytes32(address add) public pure returns (bytes32) {\n    return uint256ToBytes32(addressToUint256(add));\n  }\n\n  function uint256ToBytes32(uint256 num) public pure returns (bytes32) {\n    bytes memory addBytes = abi.encodePacked(num);\n    bytes32 out;\n    for (uint256 i = 0; i < 32; i++) {\n      out |= bytes32(addBytes[i] & 0xFF) >> (i * 8);\n    }\n    return out;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}